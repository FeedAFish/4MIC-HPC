---
fontsize: 12pt
classoption: xcolor = usenames,dvipsnames
output:
  bookdown::pdf_document2:
    papersize: a4
    fig_caption: true
    highlight: tango
    keep_tex: true
    number_sections: true
    pandoc_args: --listings
    toc_depth: 3
    toc: false
    latex_engine: xelatex
    includes:
      in_header: preamble.tex
      before_body: blas_cover.tex
---

# Techniques
## Native dot

We first mention here the original `native_dot` function for an easier comparision with different techniques below.

```{c, eval=FALSE}
void naive_dot(double *A, int lda, double *B, int ldb, double *C, int ldc) {
  int i, j, k;
/* Set the C matrix to zero */
#pragma  // TO BE FINISHED
  for (i = 0; i < M; i++)
    for (j = 0; j < N; j++) C[i + ldc * j] = 0.;
/* Perform the matrix-matrix product */
#pragma  // TO BE FINISHED
  for (i = 0; i < M; i++)
    for (j = 0; j < N; j++)
      for (k = 0; k < K; k++) C[i + ldc * j] += A[i + lda * k] * B[k + ldb * j];
}
```

## Spatial locality

Spatial locality refers to the following scenario: if a particular storage location is referenced at a particular time, then it is likely that nearby memory locations will be referenced in the near future. In order to take advantages of this property, we notice that:

  - In memory, `A`, `B`, `C` are stored in contiguous memory block.
  - When using the index order `i`, `j`, `k`, we access `B` consecutively ( as we access `B` by `B[k + ldb * j]`), but not `A` and `C`.
  - Data from `A`, `B`, `C` are loaded in a memory block consisting of severals consecutive elements to cache. Thus, we could make use of spatial locality when reading data continously.

From 3 points above, we decide to switch the index order to `k`, `j`, `i`. Now we see that both reading and writing operations on `C` are in cache, which allows a great gain in performance. In addition, reading operations on `A` are in cache too but those on `B` are not.
```{c, eval=FALSE}
void saxpy_dot(double *A, int lda, double *B, int ldb, double *C, int ldc) {
  int i, j, k;
  double temp;
/* Set the C matrix to zero */
#pragma  // TO BE FINISHED
  for (i = 0; i < M; i++)
    for (j = 0; j < N; j++) C[i + ldc * j] = 0.;
/* Perform the matrix-matrix product */
#pragma  // TO BE FINISHED
  for (k = 0; k < K; k++)
    for (j = 0; j < N; j++)
      for (i = 0; i < M; i++) C[i + ldc * j] += A[i + lda * k] * B[k + ldb * j];
}
```
