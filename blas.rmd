---
fontsize: 12pt
classoption: xcolor = usenames,dvipsnames
output:
  bookdown::pdf_document2:
    papersize: a4
    fig_caption: true
    highlight: tango
    keep_tex: true
    number_sections: true
    pandoc_args: --listings
    toc_depth: 3
    toc: false
    latex_engine: xelatex
    includes:
      in_header: preamble.tex
      before_body: blas_cover.tex
---

```{r include=FALSE}
library(kableExtra)

knitr::opts_chunk$set(fig.align = "center")
options(width=80)

library(reticulate)
use_python("/Users/vovannghia/programming/.venvs/sci/bin/python")

to_float_str <- function(num) {
  return(gsub("\\.", ",", num))
}
```

```{python include=FALSE}
import os
import subprocess
import sys

import numpy as np
import pandas as pd


def init_matrix(nrow: int, ncol: int, coff: float):
    m = np.empty((nrow, ncol))
    for i in range(nrow):
        for j in range(ncol):
            m[i, j] = coff * (i + 1 + j + 1) / nrow / ncol
    return m


def pmatrix(a: np.ndarray):
    if len(a.shape) != 2:
        raise ValueError("pmatrix can only display two dimensions")
    latex = r"\begin{pmatrix}" + "\n"
    nrow, ncol = a.shape
    for i in range(nrow):
        for j in range(ncol):
            fraction, integer = np.modf(a[i, j])
            if fraction == 0:
                latex += str(int(integer))
            else:
                latex += str(a[i, j]).replace(".", ",")
            if j != ncol - 1:
                latex += " && "
        if i != nrow - 1:
            latex += r"\\" + "\n"
    latex += "\n" + r"\end{pmatrix}"
    return latex


def compile_and_run(
    M: int = 4,
    K: int = 4,
    N: int = 4,
    printarray: bool = True,
    native: bool = True,
    saxpy: bool = True,
    blocking: bool = True,
    blas: bool = True,
    omp: bool = True,
    raw_only=False,
    print_raw=True,
):
    command = "clang" if sys.platform == "darwin" else "gcc"
    args = [command, "-o", "blas3", "blas3.c", "-O3", "-lblas", "-fopenmp", "-lm"]

    if not printarray:
        args.append("-D NO_PRINT_ARRAY")
    if not native:
        args.append("-D NO_NATIVE_DOT")
    if not saxpy:
        args.append("-D NO_SAXPY_DOT")
    if not blocking:
        args.append("-D NO_BLOCKING_DOT")
    if not blas:
        args.append("-D NO_BLAS_DOT")
    if not omp:
        args.append("-D NO_OMP")

    args.append(f"-D M={M}")
    args.append(f"-D K={K}")
    args.append(f"-D N={N}")

    log_path = ".local." + ".".join(args).replace(" ", "").replace("/", ".") + ".log"

    if sys.platform == "darwin":
        args += [
            "-I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/Accelerate.framework/Versions/Current/Frameworks/vecLib.framework/Headers/",
            "-L/usr/local/Cellar/llvm/13.0.0_2/lib/",
        ]

    subprocess.run([" ".join(args)], shell=True)

    raw_output = ""
    if os.path.exists(log_path):
        with open(log_path, "r") as f:
            raw_output = f.read()
    else:
        raw_output = subprocess.run("./blas3", capture_output=True).stdout.decode(
            "utf-8"
        )
        with open(log_path, "w") as f:
            f.write(raw_output)
    if raw_only:
        return raw_output
    if print_raw:
        print(raw_output)

    outputs = raw_output.splitlines()
    res = []
    i = 0
    while i < len(outputs):
        output = outputs[i].strip()
        if output.startswith("Total time "):
            lhs, rhs = output.split(" = ")
            name = lhs[len("Total time ") :].strip().capitalize()
            time = float(rhs)
            lhs, rhs = outputs[i - 1].strip().split(" = ")
            norm = float(rhs)
            lhs, rhs = outputs[i + 1].strip().split(" = ")
            gflops = float(rhs)
            i = i + 2
            res.append(
                {
                    "Technique": name,
                    "Time": time,
                    "Norm": norm,
                    "Gflops": gflops,
                    "M": M,
                    "K": K,
                    "N": N,
                    "OMP": omp,
                }
            )
        else:
            i = i + 1
    df = pd.DataFrame(res)
    return df, raw_output

```

# Techniques
## Native dot

We first mention here the original `native_dot` function. This function serves as an anchor (or base case) for performance comparision as well as for making sure we have the right result when using other techniques.

```{c, eval=FALSE}
for (i = 0; i < M; i++)
  for (j = 0; j < N; j++)
    for (k = 0; k < K; k++) C[i + ldc * j] += A[i + lda * k] * B[k + ldb * j];
```

Below is the output of `native_dot` for `M = 1`, `K = 2`, `N = 2`:
```{python echo=FALSE}
print(compile_and_run(1, 2, 2, saxpy=False, blocking=False, blas=False, omp=False, raw_only=True))
```
As
$$
```{python results="asis", echo=FALSE}
native_a = init_matrix(1, 2, 1)
native_b = init_matrix(2, 2, 2)
print(pmatrix(native_a) + pmatrix(native_b) + "=" + pmatrix(native_a @ native_b))
```
$$
The result of this function is correct. We could move on to the next technique.

## Spatial locality

Spatial locality refers to the following scenario: if a particular storage location is referenced at a particular time, then it is likely that nearby memory locations will be referenced in the near future. In order to take advantages of this property, we notice that:

  - In memory, `A`, `B`, `C` are stored in contiguous memory block.
  - When using the index order `i`, `j`, `k`, we access `B` consecutively (as we access `B` by `B[k + ldb * j]`), but not `A` and `C`.
  - Data from `A`, `B`, `C` are loaded in a memory block consisting of severals consecutive elements to cache. Thus, we could make use of spatial locality when reading data continously.

From 3 points above, we decide to switch the index order to `k`, `j`, `i`. Now we see that both reading and writing operations on `C` are in cache, this brings us a critical gain in performance. In addition, reading operations on `A` are in cache too but those on `B` are not.
```{c, eval=FALSE}
for (k = 0; k < K; k++)
  for (j = 0; j < N; j++)
    for (i = 0; i < M; i++) C[i + ldc * j] += A[i + lda * k] * B[k + ldb * j];
```

For comparision, we have a table below with small `M`, `K`, `N` (`OMP` indicates if we enable `Open MP` or not).
```{python include=FALSE}
M = 4
K = 8
N = 4
small_native_saxpy_df, small_native_saxpy_output = compile_and_run(
  M, K, N, True, True, True, False, False, False
)
```
```{r echo=FALSE}
kbl(
  py$small_native_saxpy_df,
  booktabs = T,
  longtable = T,
) %>% kable_styling(latex_options = "striped")
```

We have the frobenius norm of both techniques are `r to_float_str(py$small_native_saxpy_df$Norm[1])`, which indicate we have the right computation result. In addition, calculating time is already significantly small ($\approx$ 0 second in both methods) and the difference between these two can therefore be ommited.

However, if we set `M`, `K`, `N` to 2048. There will be a huge performance gain as in the table shown below.
```{python include=FALSE}
M = 2048
K = 2048
N = 2048
big_native_saxpy_df, big_native_saxpy_output = compile_and_run(
  M, K, N, False, True, True, False, False, False
)
```
```{r echo=FALSE}
kbl(
  py$big_native_saxpy_df,
  booktabs = T,
  longtable = T,
) %>% kable_styling(latex_options = "striped")
```

Here, the `native_dot` function is approximately `r round(py$big_native_saxpy_df$Time[1]/py$big_native_saxpy_df$Time[2])` times slower than the `saxpy_dot` function.
